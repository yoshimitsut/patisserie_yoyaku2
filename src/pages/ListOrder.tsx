import { useEffect, useState, useMemo, useRef } from 'react';
import { useNavigate } from "react-router-dom";
import { Html5QrcodeScanner } from 'html5-qrcode';
import Select from "react-select";

import ExcelExportButton from '../components/ExcelExportButton';

import type { StylesConfig, SingleValue } from 'react-select';
import type { Order } from '../types/types';

import './ListOrder.css';



export default function ListOrder() {
  const [orders, setOrders] = useState<Order[]>([]);
  const [loading, setLoading] = useState(true);
  const [showScanner, setShowScanner] = useState(false);
  const [scannedOrder, setScannedOrder] = useState<Order | null>(null);
  const [search, setSearch] = useState('');
  const [viewMode, setViewMode] = useState<"date" | "order">("order");
  
  const navigate = useNavigate();
  
  const handleSearch = useRef<NodeJS.Timeout | null>(null);

  useEffect(() => {
  setLoading(true);
  if (handleSearch.current) {
    clearTimeout(handleSearch.current);
  }

  handleSearch.current = setTimeout(() => {
    const searchUrl = search 
      ? `${import.meta.env.VITE_API_URL}/api/list?search=${encodeURIComponent(search)}` 
      : `${import.meta.env.VITE_API_URL}/api/list`;
  
    fetch(searchUrl)
      .then((res) => res.json())
      .then((data) => {
        // üîë garante que orders sempre √© array
        const normalized = Array.isArray(data) ? data : (data.orders || []);
        setOrders(normalized);
      })
      .catch((error) => {
        console.error('Erro ao carregar pedidos:', error);
      })
      .finally(() => setLoading(false));
  }, 500);

  return () => {
    if (handleSearch.current) {
      clearTimeout(handleSearch.current);
    }
  };
}, [search]);


  // Agora, voc√™ n√£o precisa mais do filteredOrders, use apenas 'orders' diretamente
  const groupedOrders = useMemo(() => {
    return orders.reduce((acc, order) => {
      if (!acc[order.date]) acc[order.date] = [];
      acc[order.date].push(order);
      return acc;
    }, {} as Record<string, Order[]>);
  }, [orders]);

  useEffect(() => {
    if (showScanner) {
      const scanner = new Html5QrcodeScanner('reader', { fps:10, qrbox: 250}, false);

      scanner.render(
        async (decodedText: string) => {
          setShowScanner(false);
          scanner.clear();
          try {
            const res = await fetch(`${import.meta.env.VITE_API_URL}/api/list`);
            const allOrders: Order[] = await res.json();
            const found = allOrders.find((o) => o.id_order === Number(decodedText));
            if (found) {
              setScannedOrder(found);
            } else {
              alert('Pedido n√£o encontrado.');
            }
          } catch (error) {
            console.error('Erro ao buscar pedidos:', error);
          }
        },
        (err) => {
          console.warn('Erro ao ler QR Code:', err);
        }
      );
    }
  }, [showScanner]);

  // const filteredOrders = useMemo(() => {
  //   const normalizedSeach = search.replace(/\D/g, "");

  //   return orders.filter((o) => {
  //     const idStr = String(o.id_order).padStart(4, "0"); 
  //     const normalizedTel = o.tel.replace(/\D/g, "");
      
  //     return (
  //       idStr.includes(search) ||
  //       o.id_order.toString().includes(search) || 
  //       o.first_name.toLowerCase().includes(search.toLowerCase()) ||
  //       o.last_name.toLowerCase().includes(search.toLowerCase()) ||
  //       normalizedTel.includes(normalizedSeach)
  //     );
  //   });
  // }, [orders, search]);


  // const groupedOrders = useMemo(() => {
  //   return filteredOrders.reduce((acc: Record<string, Order[]>, order) => {
  //     if (!acc[order.date]) acc[order.date] = [];
  //     acc[order.date].push(order);
  //     return acc;
  //   }, {});
  // }, [filteredOrders]);

  // transforma em array e ordena pelas datas
  const sortedGroupedOrders = useMemo(() => {
    return Object.entries(groupedOrders) as [string, Order[]][];
    // return (Object.entries(groupedOrders) as [string, Order[]][]).sort(
    //   ([dateA], [dateB]) => new Date(dateA).getTime() - new Date(dateB).getTime()
    // );
  }, [groupedOrders]);

  const displayOrders: [string, Order[]][] = useMemo(() => {
    if (viewMode === 'date') {
      return sortedGroupedOrders;
    } else {
      return [["Ê≥®ÊñáÈ†Ü", [...orders].sort((a, b) => a.id_order - b.id_order)]];
    }
  }, [viewMode, sortedGroupedOrders, orders]);

  type StatusOption = {
    value: "1" | "2" | "3" | "4";
    label: string;
  };

  const statusOptions: StatusOption[] = [
    { value: "1", label: "Êú™" },
    { value: "2", label: "„Éç„ÉÉ„ÉàÊ±∫Ê∏àÊ∏à" },
    { value: "3", label: "Â∫óÈ†≠ÊîØÊâï„ÅÑÊ∏à" },
    { value: "4", label: "„ÅäÊ∏°„ÅóÊ∏à" },
  ];


  function handleStatusChange(id_order: number, newStatus: "1" | "2" | "3" | "4") {
    const order = orders.find((o) => o.id_order === id_order);
    if(!order) return;

    const statusMap: Record<string, string> = {
      "1": "Êú™",
      "2": "„Éç„ÉÉ„ÉàÊ±∫Ê∏àÊ∏à",
      "3": "Â∫óÈ†≠ÊîØÊâï„ÅÑÊ∏à",
      "4": "„ÅäÊ∏°„ÅóÊ∏à",
    };

    const currentStatus = statusMap[order.status ?? "1"];
    const nextStatus = statusMap[newStatus];

    const confirmed = window.confirm(
      `(Á¢∫Ë™ç)„Çπ„ÉÜ„Éº„Çø„Çπ„ÇíÂ§âÊõ¥„Åó„Åæ„Åô„ÅãÔºü\n\n` +
      `Âèó‰ªòÁï™Âè∑: ${order.id_order}\n` +
      `„ÅäÂêçÂâç: ${order.first_name} ${order.last_name}\n\n` +
      `${currentStatus} ‚Üí ${nextStatus}`
    );

    if (!confirmed) return;

    setOrders((oldOrder) =>
      oldOrder.map((order) => 
        order.id_order === id_order ? {...order, status: newStatus } : order
      )
    );

    //Atualiza no backend
    fetch(`${import.meta.env.VITE_API_URL}/api/reservar/${id_order}`, {
      method: "PUT",
      headers: {
        "Content-Type": "application/json"
      },
      body:JSON.stringify({ status: newStatus }),
    })
    .then((res) => res.json())
    .then((data) => {
      console.log("Statos atualizado no Servidor:", data);
    })
    .catch((err) => {
      console.log("Erro ao atualizar status", err)
    })
  }

  const customStyles: StylesConfig<StatusOption, false> = {
    control: (provided, state) => {
      const selected = state.selectProps.value as StatusOption | null;

      let bgColor = "#000";
      let fontColor = "#FFF";

      if (selected) {
        switch (selected.value) {
          case "1":
            bgColor = "#C40000"; // amarelo
            fontColor = "#FFF";
            break;
          case "2":
            bgColor = "#000DBD"; // verde
            fontColor = "#FFF";
            break;
          case "3":
            bgColor = "#287300"; // vermelho
            fontColor = "#FFF";
            break;
          case "4":
            bgColor = "#6B6B6B"; // vermelho
            fontColor = "#FFF";
            break;
          default:
            bgColor = "#000";
            fontColor = "#FFF";
        }
      }

      return {
        ...provided,
        borderRadius: 8,
        borderColor: "none",
        // boxShadow: state.isFocused ? "0 0 0 2px rgba(0,123,255,0.25)" : "none",
        minHeight: 36,
        backgroundColor: bgColor,
        color: fontColor,
      };
    },
    singleValue: (provided) => {
      // garante fonte branca no texto selecionado
      return {
        ...provided,
        color: "white",
      };
    },
    option: (provided, state) => {
      let bgColor = "white";
      let fontColor = "#FFF";

      switch ((state.data as StatusOption).value) {
        case "1":
          bgColor = state.isFocused ? "#C40000" : "white";
          fontColor = state.isFocused ? "white" : "black";
          break;
        case "2":
          bgColor = state.isFocused ? "#000DBD" : "white";
          fontColor = state.isFocused ? "white" : "black";
          break;
        case "3":
          bgColor = state.isFocused ? "#287300" : "white";
          fontColor = state.isFocused ? "white" : "black";
          break;
        case "4":
          bgColor = state.isFocused ? "#6B6B6B" : "white";
          fontColor = state.isFocused ? "white" : "black";
          break;
      }

      return {
        ...provided,
        backgroundColor: bgColor,
        color: fontColor,
      };
    },
    dropdownIndicator: (provided) => ({
      ...provided,
      padding: "1px",
    }),
  };

  return (
    <div className='list-order-container'>
      <div className="list-order-actions">
        
        <input 
            type="text" 
            placeholder='Ê§úÁ¥¢Ôºö„ÅäÂêçÂâç„ÄÅÈõªË©±Áï™Âè∑„ÄÅÂèó‰ªòÁï™Âè∑„Å™„Å©„ÇíÂÖ•Âäõ'
            value={search}
            onChange={(e) => setSearch(e.target.value)}
            className='list-order-input'
          />
        
        <div className='btn-actions'>
          <ExcelExportButton data={orders} filename='Ê≥®Êñá„Ç±„Éº„Ç≠.xlsx' sheetName='Ê≥®Êñá' />
          <button onClick={() => setShowScanner(true)} className='list-btn'>
            <img src="/icons/qrCodeImg.avif" alt="qrcode icon" />
          </button>
          <button onClick={() => navigate("/graphic")} className='list-btn'>
            <img src="/icons/table.avif" alt="graphic icon" />
          </button>
        </div>


      </div>
      
      {showScanner && (
        <div id="reader" style={{ width: '300px', marginBottom: 20 }}></div>
      )}

      {scannedOrder && (
        <div style={{ border: '1px solid #007bff', padding: 12, marginBottom:20 }}>
          <strong>
            <Select
              options={statusOptions}
              value={statusOptions.find((opt) => opt.value === scannedOrder.status)}
              onChange={(selected) =>
                handleStatusChange(
                  scannedOrder.id_order,
                  selected?.value as "1" | "2" | "3" | "4"
                )
              }
              styles={customStyles}
              isSearchable={false}
            />
          </strong>
          <strong>Âèó‰ªòÁï™Âè∑: </strong> {scannedOrder.id_order}<br />
          <strong>„ÅäÂêçÂâç: </strong> {scannedOrder.first_name} {scannedOrder.last_name}<br />
          <strong>ÈõªË©±Áï™Âè∑: </strong> {scannedOrder.tel}<br />
          <strong>ÂèóÂèñÊó•: </strong> {scannedOrder.date} - {scannedOrder.pickupHour}<br />
          <strong>„ÅîÊ≥®Êñá„ÅÆ„Ç±„Éº„Ç≠: </strong> 
          <ul className='cake-list'>
            {scannedOrder.cakes.map((cake, index) => (
              <li key={`${cake.id_cake}-${index}`}>
                <span className='cake-name'>{cake.name}</span>
                <span className='cake-amount'>¬•{cake.size}</span>
                <span className='cake-size'>ÂÄãÊï∞: {cake.amount}</span>
              </li>
            ))}
          </ul>
        </div>
      )}

      {loading ? (
        <p>Loading...</p>  
      ) : orders.length === 0 ? (
        <p>Ê≥®Êñá„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ</p>
      ) : (
        <>
          <Select 
          options={[
            { value: "date", label: "ÂèóÂèñÊó•È†Ü" },  
            { value: "order", label: "Âèó‰ªòÁï™Âè∑È†Ü" }, 
          ]}
          value={
            { value: viewMode, 
              label: viewMode === "date" ? "ÂèóÂèñÊó•È†Ü" : "Âèó‰ªòÁï™Âè∑È†Ü", 
            }}
          onChange={(opt) => setViewMode(opt?.value as "date" | "order")}
          isSearchable={false}
          styles={{ container: (base) => ({ ...base, wiidth: 200 }) }}
        />
          
          {/* Tabelas (desktop) */}
          {displayOrders.map(([groupTitles, ordersForGroup]: [string, Order[]]) => {
            const totalProdutos = ordersForGroup.reduce(
              (sum, order) => sum + order.cakes.reduce((s, c) => s + c.amount, 0),
              0
            );

            const totalValor = ordersForGroup.reduce(
              (sum, order) =>
                sum +
                order.cakes.reduce((s, c) => s + (c.price) * c.amount, 0),
              0
            );
            return (
            <div key={groupTitles} className="table-wrapper scroll-cell">
              {/* <h3 style={{ background: "#f0f0f0", padding: "8px" }}>{groupTitles}</h3> */}
              
              <table className="list-order-table">
                <thead>
                  <tr>
                    <th className='id-cell'>Âèó‰ªòÁï™Âè∑</th>
                    <th className='situation-cell'>„Åä‰ºöË®à</th>
                    <th>„ÅäÂêçÂâç</th>
                    <th>ÂèóÂèñÂ∏åÊúõÊó•ÊôÇ</th>
                    <th>„ÅîÊ≥®Êñá„ÅÆ„Ç±„Éº„Ç≠</th>
                    {/* <th>ÂÄ§ÊÆµ</th> */}
                    <th>ÂÄãÊï∞</th>
                    <th>„É°„ÉÉ„Çª„Éº„Ç∏</th>
                    <th>„É°„ÉÉ„Çª„Éº„Ç∏</th>
                    <th>ÈõªË©±Áï™Âè∑</th>
                    <th>„É°„Éº„É´„Ç¢„Éâ„É¨„Çπ</th>
                  </tr>
                </thead>
                <tbody>
                  {ordersForGroup.map((order) => (
                    <tr key={order.id_order}>
                      <td>{String(order.id_order).padStart(4, "0")}</td>
                      <td className='situation-cell'>
                        <Select<StatusOption, false>
                          options={statusOptions}
                          value={statusOptions.find((opt) => opt.value === order.status)}
                          onChange={(selected: SingleValue<StatusOption>) => {
                            if (selected) handleStatusChange(order.id_order, selected.value);
                          }}
                          styles={customStyles}
                          isSearchable={false}
                        />
                      </td>
                      <td>
                        {order.first_name} {order.last_name}
                      </td>
                      <td>{order.date} {order.pickupHour}</td>
                      <td>
        <ul>
          {order.cakes.map((cake, index) => (
            <li key={`${order.id_order}-${cake.id_cake}-${index}`}>
              {cake.name} 
              {cake.size} - ¬•{cake.price}<br />
            </li>
          ))}
        </ul>
      </td>
      <td style={{ textAlign: "center" }}>
        <ul>
          {order.cakes.map((cake, index) => (
            <li key={`${order.id_order}-${cake.id_cake}-${index}`}>
              {cake.amount}
            </li>
          ))}
        </ul>
      </td>
      <td style={{ textAlign: "center" }}>
        <ul>
          {order.cakes.map((cake, index) => (
            <li key={`${order.id_order}-${cake.id_cake}-${index}`}>
              {cake.message_cake}
            </li>
          ))}
        </ul>
      </td>
                      {/* <td>
                        <table className='table-cake' style={{width: "100%"}}>
                          <thead>
                          <tr className='description'>
                            <th>„Ç±„Éº„Ç≠Âêç</th>
                            <th>„Çµ„Ç§„Ç∫</th>
                            <th>ÂÄ§ÊÆµ</th>
                            <th>ÂÄãÊï∞</th>
                            <th>„É°„ÉÉ„Çª„Éº„Ç∏</th>
                          </tr>
                        </thead>
                          <tbody>

                            {order.cakes.map((cake, index) => (
                              <tr key={`${order.id_order}-${cake.id_cake}-${index}`}>
                                <td>{cake.name}
                                </td>
                                <td>
                                  ¬•{cake.price}
                                </td>
                                <td>
                                  {cake.amount}
                                </td>
                                <td>
                                  {cake.size}
                                </td>
                                <td>
                                  {cake.message_cake}
                                </td>
                              </tr>
                            ))}

                          </tbody>
                        </table>
                      </td> */}
                      
                      <td>{order.message || " "}</td>
                      <td>{order.tel}</td>
                      <td>{order.email}</td>
                    </tr>
                  ))}
                </tbody>
              </table>
              {/* Totais por dia */}
              <div className="day-summary">
                <strong>ÂêàË®àÂïÜÂìÅÊï∞: </strong> {totalProdutos} ÂÄã
                <br />
                <strong>ÂêàË®àÈáëÈ°ç: </strong> ¬•{totalValor.toLocaleString()}
              </div>
            </div>
            );  
        })}
      

          {/* Cards (mobile) */}
          <div className="mobile-orders">
            {orders.map((order) => (
              <div className="order-card" key={order.id_order}>
                <div className="order-header">
                  <span>Âèó‰ªòÁï™Âè∑: {order.id_order}</span>
                  <span>{order.status}</span>
                </div>
                  <Select
                    options={statusOptions}
                    value={statusOptions.find((opt) => opt.value === order.status)}
                    onChange={(selected) =>
                      handleStatusChange(order.id_order, selected?.value as "1" | "2" | "3" | "4")
                    }
                  />
                <p>„ÅäÂêçÂâç: {order.first_name} {order.last_name}</p>
                <p>ÂèóÂèñÊó•: {order.date} {order.pickupHour}</p>
                <details>
                  <summary>„ÅîÊ≥®ÊñáÂÜÖÂÆπ</summary>
                  <ul>
                    {order.cakes.map((cake, index) => (
                      <li key={`${cake.id_cake}-${index}`}>
                        {cake.name} - ÂÄãÊï∞: {cake.amount} - {cake.size}
                      </li>
                    ))}
                  </ul>
                  <p>ÈõªË©±Áï™Âè∑: {order.tel}</p>
                  <p>„É°„ÉÉ„Çª„Éº„Ç∏: {order.message || " "}</p>
                </details>
              </div>
            
            ))}
          </div>
        </>
      )}
    </div>
  );
};